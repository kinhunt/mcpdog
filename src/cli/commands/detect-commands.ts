/**
 * Protocol detection CLI commands
 */

import { ConfigManager } from '../../config/config-manager.js';
import { CLIUtils } from '../cli-utils.js';

export class DetectCommands {
  constructor(private configManager: ConfigManager) {}

  async execute(args: string[], options: Record<string, any>): Promise<void> {
    if (options.help) {
      this.showHelp();
      return;
    }

    if (options.all) {
      await this.detectAllServers(options);
    } else {
      const [target] = args;
      if (!target) {
        CLIUtils.error('Usage: mcpdog detect <server-name|endpoint> or mcpdog detect --all');
        return;
      }
      await this.detectTarget(target, options);
    }
  }

  private async detectTarget(target: string, options: Record<string, any>): Promise<void> {
    try {
      // Determine if it's a server name or endpoint URL
      const existingServer = this.configManager.getServer(target);
      
      if (existingServer) {
        // Detect existing server
        await this.detectExistingServer(target, options);
      } else if (target.startsWith('http://') || target.startsWith('https://')) {
        // Detect new endpoint
        await this.detectNewEndpoint(target, options);
      } else {
        // May be a stdio command
        await this.detectStdioCommand(target, options);
      }

    } catch (error) {
      CLIUtils.error(`Protocol detection failed: ${(error as Error).message}`);
      if (CLIUtils.isJsonMode()) {
        CLIUtils.jsonOutput({ success: false, error: (error as Error).message });
      }
      process.exit(1);
    }
  }

  private async detectExistingServer(serverName: string, options: Record<string, any>): Promise<void> {
    const server = this.configManager.getServer(serverName)!;
    
    CLIUtils.info(`üîç Detecting server: ${serverName}`);
    CLIUtils.verbose(`Endpoint: ${server.endpoint || server.command}`);

    const detection = await this.configManager.detectConfigProtocol(server);

    if (CLIUtils.isJsonMode()) {
      CLIUtils.jsonOutput({
        server: serverName,
        current: server.transport,
        detected: detection.detected,
        confidence: detection.confidence,
        recommendations: detection.recommendations
      });
      return;
    }

    console.log(`\n${CLIUtils.colorize('üìä Detection Results:', 'cyan')}`);
    console.log(`Server: ${CLIUtils.colorize(serverName, 'yellow')}`);
    console.log(`Current Protocol: ${CLIUtils.colorize(server.transport, 'blue')}`);
    console.log(`Detected Protocol: ${CLIUtils.colorize(detection.detected, detection.detected === server.transport ? 'green' : 'yellow')}`);
    console.log(`Confidence: ${this.formatConfidence(detection.confidence)}`);
    
    if (detection.recommendations.length > 0) {
      console.log(`\n${CLIUtils.colorize('üí° Recommendations:', 'cyan')}`);
      detection.recommendations.forEach((rec: string) => {
        console.log(`  ‚Ä¢ ${rec}`);
      });
    }

    // If a better protocol is detected, ask whether to update
    if (detection.detected !== server.transport && detection.confidence > 70) {
      const shouldUpdate = options.yes || await CLIUtils.confirm(
        `Detected better protocol ${detection.detected}, update configuration?`,
        false
      );

      if (shouldUpdate) {
        await this.configManager.updateServer(serverName, { transport: detection.detected as any });
        CLIUtils.success(`‚úÖ Server '${serverName}' protocol updated to ${detection.detected}`);
      }
    }
  }

  private async detectNewEndpoint(endpoint: string, options: Record<string, any>): Promise<void> {
    CLIUtils.info(`üîç Detecting new endpoint: ${endpoint}`);

    // Use AutoConfigGenerator directly for endpoint detection
    const { AutoConfigGenerator } = await import('../../core/auto-config-generator.js');
    const generator = new AutoConfigGenerator();
    const suggestion = await generator.generateConfig(
      'temp-detection',
      endpoint,
      {
        timeout: options.timeout ? parseInt(options.timeout) : undefined
      }
    );

    if (CLIUtils.isJsonMode()) {
      CLIUtils.jsonOutput({
        endpoint,
        detected: suggestion.config.transport,
        confidence: suggestion.confidence,
        config: suggestion.config,
        alternatives: suggestion.alternatives,
        warnings: suggestion.warnings,
        optimizations: suggestion.optimizations
      });
      return;
    }

    console.log(`\n${CLIUtils.colorize('üìä Detection Results:', 'cyan')}`);
    console.log(`Endpoint: ${CLIUtils.colorize(endpoint, 'yellow')}`);
    console.log(`Recommended Protocol: ${CLIUtils.colorize(suggestion.config.transport, 'green')}`);
    console.log(`Confidence: ${this.formatConfidence(suggestion.confidence)}`);
    
    if (options.detailed) {
      console.log(`\n${CLIUtils.colorize('üîß Suggested Configuration:', 'cyan')}`);
      console.log(`  Transport Protocol: ${suggestion.config.transport}`);
      console.log(`  Timeout: ${suggestion.config.timeout}ms`);
      console.log(`  Retry Count: ${suggestion.config.retries}`);
      console.log(`  Session Mode: ${suggestion.config.sessionMode || 'Default'}`);
    }

    if (suggestion.alternatives.length > 0) {
      console.log(`\n${CLIUtils.colorize('üîÑ Alternatives:', 'cyan')}`);
      suggestion.alternatives.forEach((alt, index) => {
        console.log(`  ${index + 1}. ${alt.transport} - ${alt.description}`);
      });
    }

    if (suggestion.warnings.length > 0) {
      console.log(`\n${CLIUtils.colorize('‚ö†Ô∏è  Warnings:', 'yellow')}`);
      suggestion.warnings.forEach(warning => {
        console.log(`  ‚Ä¢ ${warning}`);
      });
    }

    if (suggestion.optimizations.length > 0) {
      console.log(`\n${CLIUtils.colorize('üí° Optimization Suggestions:', 'cyan')}`);
      suggestion.optimizations.forEach(opt => {
        console.log(`  ‚Ä¢ ${opt}`);
      });
    }

    // Ask whether to add server
    if (!options['no-add']) {
      const shouldAdd = await CLIUtils.confirm(
        'Add new server based on detection results?',
        false
      );

      if (shouldAdd) {
        const { createInterface } = await import('readline');
        const rl = createInterface({
          input: process.stdin,
          output: process.stdout
        });

        const serverName = await new Promise<string>((resolve) => {
          rl.question('Please enter server name: ', resolve);
        });
        rl.close();

        if (serverName.trim()) {
          await this.configManager.addServer(serverName.trim(), suggestion.config);
          CLIUtils.success(`‚úÖ Server '${serverName.trim()}' added successfully`);
        }
      }
    }
  }

  private async detectStdioCommand(command: string, options: Record<string, any>): Promise<void> {
    CLIUtils.info(`üîç Detecting stdio command: ${command}`);

    // For stdio commands, we directly suggest stdio protocol
    const suggestion = {
      protocol: 'stdio',
      confidence: 95,
      reason: 'Command-based MCP server detected',
      features: ['PROCESS_COMMUNICATION', 'DIRECT_EXECUTION']
    };

    if (CLIUtils.isJsonMode()) {
      CLIUtils.jsonOutput({
        command,
        detected: suggestion.protocol,
        confidence: suggestion.confidence,
        reason: suggestion.reason,
        features: suggestion.features
      });
      return;
    }

    console.log(`\n${CLIUtils.colorize('üìä Detection Results:', 'cyan')}`);
    console.log(`Command: ${CLIUtils.colorize(command, 'yellow')}`);
    console.log(`Recommended Protocol: ${CLIUtils.colorize('stdio', 'green')}`);
    console.log(`Confidence: ${this.formatConfidence(suggestion.confidence)}`);
    console.log(`Reason: ${suggestion.reason}`);

    console.log(`\n${CLIUtils.colorize('üîß Suggested Configuration:', 'cyan')}`);
    console.log(`  Transport Protocol: stdio`);
    console.log(`  Command: ${command}`);
    console.log(`  Timeout: 60000ms (stdio recommends longer)`);
  }

  private async detectAllServers(options: Record<string, any>): Promise<void> {
    const servers = this.configManager.getServers();
    
    if (Object.keys(servers).length === 0) {
      CLIUtils.info('No servers configured');
      return;
    }

    CLIUtils.info(`üîç Batch detecting protocols for ${Object.keys(servers).length} servers...`);

    const results = await this.configManager.auditAllServerProtocols();

    if (CLIUtils.isJsonMode()) {
      const jsonResults = Object.entries(results).map(([name, result]) => ({
        server: name,
        ...result
      }));
      CLIUtils.jsonOutput(jsonResults);
      return;
    }

    console.log(`\n${CLIUtils.colorize('üìä Batch Detection Results:', 'cyan')}\n`);

    const headers = ['Server', 'Current Protocol', 'Detected Protocol', 'Confidence', 'Status', 'Recommendation'];
    const rows: string[][] = [];

    for (const [serverName, result] of Object.entries(results)) {
      const status = result.needsUpdate ? 
        CLIUtils.colorize('Needs Update', 'yellow') : 
        CLIUtils.colorize('OK', 'green');
      
      const mainRecommendation = result.recommendations[0] || 'None';
      
      rows.push([
        serverName,
        result.current,
        result.detected,
        this.formatConfidence(result.confidence),
        status,
        mainRecommendation.length > 40 ? mainRecommendation.substring(0, 37) + '...' : mainRecommendation
      ]);
    }

    CLIUtils.printTable(headers, rows);

    // Statistics
    const needsUpdate = Object.values(results).filter((r: any) => r.needsUpdate).length;
    const highConfidence = Object.values(results).filter((r: any) => r.confidence > 80).length;

    console.log(`\n${CLIUtils.colorize('üìà Statistics:', 'cyan')}`);
    console.log(`  Total Servers: ${Object.keys(servers).length}`);
    console.log(`  Need Update: ${needsUpdate}`);
    console.log(`  High Confidence Detection: ${highConfidence}`);

    if (needsUpdate > 0) {
      const shouldUpdate = options.yes || await CLIUtils.confirm(
        `Found ${needsUpdate} servers that can be optimized, batch update?`,
        false
      );

      if (shouldUpdate) {
        let updated = 0;
        for (const [serverName, result] of Object.entries(results)) {
          if (result.needsUpdate) {
            try {
              await this.configManager.updateServer(serverName, { 
                transport: result.detected as any 
              });
              updated++;
              CLIUtils.verbose(`‚úÖ Updated server '${serverName}' protocol to ${result.detected}`);
            } catch (error) {
              CLIUtils.warning(`Failed to update server '${serverName}': ${(error as Error).message}`);
            }
          }
        }
        CLIUtils.success(`‚úÖ Successfully updated ${updated} server configurations`);
      }
    }
  }

  private formatConfidence(confidence: number): string {
    if (confidence >= 90) {
      return CLIUtils.colorize(`${confidence}% (Very High)`, 'green');
    } else if (confidence >= 70) {
      return CLIUtils.colorize(`${confidence}% (High)`, 'green');
    } else if (confidence >= 50) {
      return CLIUtils.colorize(`${confidence}% (Medium)`, 'yellow');
    } else {
      return CLIUtils.colorize(`${confidence}% (Low)`, 'red');
    }
  }

  private showHelp(): void {
    console.log(`
${CLIUtils.colorize('mcpdog detect', 'cyan')} - ÂçèËÆÆÊ£ÄÊµã

${CLIUtils.colorize('‰ΩøÁî®ÊñπÊ≥ï:', 'yellow')}
  mcpdog detect <server-name|endpoint> [options]
  mcpdog detect --all [options]

${CLIUtils.colorize('ÈÄâÈ°π:', 'yellow')}
  --all                  Ê£ÄÊµãÊâÄÊúâÈÖçÁΩÆÁöÑÊúçÂä°Âô®
  --timeout <ms>         Ê£ÄÊµãË∂ÖÊó∂Êó∂Èó¥ (ÈªòËÆ§: 10000)
  --detailed             ÊòæÁ§∫ËØ¶ÁªÜÊ£ÄÊµã‰ø°ÊÅØ
  --no-add               ‰∏çËØ¢ÈóÆÊòØÂê¶Ê∑ªÂä†Êñ∞ÊúçÂä°Âô®
  --yes                  Ëá™Âä®Á°ÆËÆ§ÊâÄÊúâÊìç‰Ωú

${CLIUtils.colorize('Á§∫‰æã:', 'yellow')}
  mcpdog detect my-server                      # Ê£ÄÊµãÁé∞ÊúâÊúçÂä°Âô®
  mcpdog detect https://api.example.com        # Ê£ÄÊµãÊñ∞Á´ØÁÇπ
  mcpdog detect "node mcp-server.js"           # Ê£ÄÊµãstdioÂëΩ‰ª§
  mcpdog detect --all                          # Ê£ÄÊµãÊâÄÊúâÊúçÂä°Âô®
  mcpdog detect --all --yes                    # ÊâπÈáèÊ£ÄÊµãÂπ∂Ëá™Âä®Êõ¥Êñ∞
  mcpdog detect new-api --detailed             # ËØ¶ÁªÜÊ£ÄÊµã‰ø°ÊÅØ

${CLIUtils.colorize('ËæìÂá∫ËØ¥Êòé:', 'yellow')}
  ÁΩÆ‰ø°Â∫¶ 90%+: ÊûÅÈ´òÂèØ‰ø°Â∫¶ÔºåÂº∫ÁÉàÂª∫ËÆÆ‰ΩøÁî®
  ÁΩÆ‰ø°Â∫¶ 70-89%: È´òÂèØ‰ø°Â∫¶ÔºåÂª∫ËÆÆ‰ΩøÁî®
  ÁΩÆ‰ø°Â∫¶ 50-69%: ‰∏≠Á≠âÂèØ‰ø°Â∫¶ÔºåÂèØ‰ª•Â∞ùËØï
  ÁΩÆ‰ø°Â∫¶ <50%: ‰ΩéÂèØ‰ø°Â∫¶ÔºåÈúÄË¶ÅÊâãÂä®È™åËØÅ
`);
  }
}